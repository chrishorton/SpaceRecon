// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package OEM

import (
	flatbuffers "github.com/google/flatbuffers/go"

		RFM "github.com/chrishorton/spacerecon/pkg/flatbuffers/RFM"	
		TIM "github.com/chrishorton/spacerecon/pkg/flatbuffers/TIM"
)

/// OEM Ephemeris Data Block
type ephemerisDataBlock struct {
	_tab flatbuffers.Table
}

func GetRootAsephemerisDataBlock(buf []byte, offset flatbuffers.UOffsetT) *ephemerisDataBlock {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ephemerisDataBlock{}
	x.Init(buf, n+offset)
	return x
}

func FinishephemerisDataBlockBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsephemerisDataBlock(buf []byte, offset flatbuffers.UOffsetT) *ephemerisDataBlock {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ephemerisDataBlock{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedephemerisDataBlockBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *ephemerisDataBlock) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ephemerisDataBlock) Table() flatbuffers.Table {
	return rcv._tab
}

/// Plain-Text Comment
func (rcv *ephemerisDataBlock) Comment() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Plain-Text Comment
/// Satellite Name(s)
func (rcv *ephemerisDataBlock) ObjectName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Satellite Name(s)
/// International Designator (YYYY-NNNAAA)
func (rcv *ephemerisDataBlock) ObjectId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International Designator (YYYY-NNNAAA)
/// Origin of reference frame (EARTH, MARS, MOON, etc.)
func (rcv *ephemerisDataBlock) CenterName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Origin of reference frame (EARTH, MARS, MOON, etc.)
/// Name of the reference frame (TEME, EME2000, etc.)
func (rcv *ephemerisDataBlock) ReferenceFrame() RFM.RefFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return RFM.RefFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Name of the reference frame (TEME, EME2000, etc.)
func (rcv *ephemerisDataBlock) MutateReferenceFrame(n RFM.RefFrame) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

/// Epoch of reference frame, if not intrinsic to the definition of the reference frame
func (rcv *ephemerisDataBlock) ReferenceFrameEpoch() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Epoch of reference frame, if not intrinsic to the definition of the reference frame
/// Time system used for the orbit state and covariance matrix. (UTC)
func (rcv *ephemerisDataBlock) TimeSystem() TIM.TimeSystem {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return TIM.TimeSystem(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Time system used for the orbit state and covariance matrix. (UTC)
func (rcv *ephemerisDataBlock) MutateTimeSystem(n TIM.TimeSystem) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

/// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
func (rcv *ephemerisDataBlock) StartTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
/// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
func (rcv *ephemerisDataBlock) UseableStartTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
/// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
func (rcv *ephemerisDataBlock) UseableStopTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
/// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
func (rcv *ephemerisDataBlock) StopTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
/// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
func (rcv *ephemerisDataBlock) Interpolation() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
/// Recommended interpolation degree for ephemeris data
func (rcv *ephemerisDataBlock) InterpolationDegree() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Recommended interpolation degree for ephemeris data
func (rcv *ephemerisDataBlock) MutateInterpolationDegree(n uint32) bool {
	return rcv._tab.MutateUint32Slot(28, n)
}

/// Array of ephemeris data lines
func (rcv *ephemerisDataBlock) EphemerisDataLines(obj *ephemerisDataLine, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ephemerisDataBlock) EphemerisDataLinesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Array of ephemeris data lines
/// Array of covariance matrix lines
func (rcv *ephemerisDataBlock) CovarianceMatrixLines(obj *covarianceMatrixLine, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ephemerisDataBlock) CovarianceMatrixLinesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Array of covariance matrix lines
func ephemerisDataBlockStart(builder *flatbuffers.Builder) {
	builder.StartObject(15)
}
func ephemerisDataBlockAddComment(builder *flatbuffers.Builder, comment flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(comment), 0)
}
func ephemerisDataBlockAddObjectName(builder *flatbuffers.Builder, objectName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(objectName), 0)
}
func ephemerisDataBlockAddObjectId(builder *flatbuffers.Builder, objectId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(objectId), 0)
}
func ephemerisDataBlockAddCenterName(builder *flatbuffers.Builder, centerName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(centerName), 0)
}
func ephemerisDataBlockAddReferenceFrame(builder *flatbuffers.Builder, referenceFrame RFM.RefFrame) {
	builder.PrependInt8Slot(4, int8(referenceFrame), 0)
}
func ephemerisDataBlockAddReferenceFrameEpoch(builder *flatbuffers.Builder, referenceFrameEpoch flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(referenceFrameEpoch), 0)
}
func ephemerisDataBlockAddTimeSystem(builder *flatbuffers.Builder, timeSystem TIM.TimeSystem) {
	builder.PrependInt8Slot(6, int8(timeSystem), 0)
}
func ephemerisDataBlockAddStartTime(builder *flatbuffers.Builder, startTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(startTime), 0)
}
func ephemerisDataBlockAddUseableStartTime(builder *flatbuffers.Builder, useableStartTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(useableStartTime), 0)
}
func ephemerisDataBlockAddUseableStopTime(builder *flatbuffers.Builder, useableStopTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(useableStopTime), 0)
}
func ephemerisDataBlockAddStopTime(builder *flatbuffers.Builder, stopTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(stopTime), 0)
}
func ephemerisDataBlockAddInterpolation(builder *flatbuffers.Builder, interpolation flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(interpolation), 0)
}
func ephemerisDataBlockAddInterpolationDegree(builder *flatbuffers.Builder, interpolationDegree uint32) {
	builder.PrependUint32Slot(12, interpolationDegree, 0)
}
func ephemerisDataBlockAddEphemerisDataLines(builder *flatbuffers.Builder, ephemerisDataLines flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(ephemerisDataLines), 0)
}
func ephemerisDataBlockStartEphemerisDataLinesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ephemerisDataBlockAddCovarianceMatrixLines(builder *flatbuffers.Builder, covarianceMatrixLines flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(covarianceMatrixLines), 0)
}
func ephemerisDataBlockStartCovarianceMatrixLinesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ephemerisDataBlockEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
