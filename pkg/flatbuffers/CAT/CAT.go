// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CAT

import (
	flatbuffers "github.com/google/flatbuffers/go"

	LCC "github.com/chrishorton/spacerecon/pkg/flatbuffers/LCC"
	PLD "github.com/chrishorton/spacerecon/pkg/flatbuffers/PLD"
)

/// Catalog Entity Message
type CAT struct {
	_tab flatbuffers.Table
}

const CATIdentifier = "$CAT"

func GetRootAsCAT(buf []byte, offset flatbuffers.UOffsetT) *CAT {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CAT{}
	x.Init(buf, n+offset)
	return x
}

func FinishCATBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CATIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func CATBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, CATIdentifier)
}

func GetSizePrefixedRootAsCAT(buf []byte, offset flatbuffers.UOffsetT) *CAT {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CAT{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCATBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CATIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedCATBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, CATIdentifier)
}

func (rcv *CAT) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CAT) Table() flatbuffers.Table {
	return rcv._tab
}

/// Satellite Name(s)
func (rcv *CAT) ObjectName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Satellite Name(s)
/// International Designator (YYYY-NNNAAA)
func (rcv *CAT) ObjectId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// International Designator (YYYY-NNNAAA)
/// NORAD Catalog Number
func (rcv *CAT) NoradCatId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// NORAD Catalog Number
func (rcv *CAT) MutateNoradCatId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(8, n)
}

/// Object type (Payload, Rocket body, Debris, Unknown)
func (rcv *CAT) ObjectType() objectType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return objectType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 3
}

/// Object type (Payload, Rocket body, Debris, Unknown)
func (rcv *CAT) MutateObjectType(n objectType) bool {
	return rcv._tab.MutateInt8Slot(10, int8(n))
}

/// Operational Status Code
func (rcv *CAT) OpsStatusCode() opsStatusCode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return opsStatusCode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 7
}

/// Operational Status Code
func (rcv *CAT) MutateOpsStatusCode(n opsStatusCode) bool {
	return rcv._tab.MutateInt8Slot(12, int8(n))
}

/// Ownership, typically country or company
func (rcv *CAT) Owner() LCC.LegacyCountryCode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return LCC.LegacyCountryCode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Ownership, typically country or company
func (rcv *CAT) MutateOwner(n LCC.LegacyCountryCode) bool {
	return rcv._tab.MutateInt8Slot(14, int8(n))
}

/// Launch Date [year-month-day] (ISO 8601)
func (rcv *CAT) LaunchDate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Launch Date [year-month-day] (ISO 8601)
/// Launch Site
func (rcv *CAT) LaunchSite() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Launch Site
/// Decay Date, if applicable [year-month-day] (ISO 8601)
func (rcv *CAT) DecayDate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Decay Date, if applicable [year-month-day] (ISO 8601)
/// Orbital period [minutes]
func (rcv *CAT) Period() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Orbital period [minutes]
func (rcv *CAT) MutatePeriod(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// Inclination [degrees]
func (rcv *CAT) Inclination() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inclination [degrees]
func (rcv *CAT) MutateInclination(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Apogee Altitude [kilometers]
func (rcv *CAT) Apogee() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Apogee Altitude [kilometers]
func (rcv *CAT) MutateApogee(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// Perigee Altitude [kilometers]
func (rcv *CAT) Perigee() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Perigee Altitude [kilometers]
func (rcv *CAT) MutatePerigee(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Radar Cross Section [meters2]; blank if no data available
func (rcv *CAT) Rcs() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Radar Cross Section [meters2]; blank if no data available
func (rcv *CAT) MutateRcs(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Data status code; blank otherwise
func (rcv *CAT) DataStatusCode() dataStatusCode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return dataStatusCode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Data status code; blank otherwise
func (rcv *CAT) MutateDataStatusCode(n dataStatusCode) bool {
	return rcv._tab.MutateInt8Slot(32, int8(n))
}

/// Orbit center
func (rcv *CAT) OrbitCenter() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Orbit center
/// Orbit type (Orbit, Landing, Impact, Docked to RSO, roundtrip)
func (rcv *CAT) OrbitType() orbitType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return orbitType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Orbit type (Orbit, Landing, Impact, Docked to RSO, roundtrip)
func (rcv *CAT) MutateOrbitType(n orbitType) bool {
	return rcv._tab.MutateInt8Slot(36, int8(n))
}

/// Deployment Date [year-month-day] (ISO 8601)
func (rcv *CAT) DeploymentDate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Deployment Date [year-month-day] (ISO 8601)
/// Indicates if the object is maneuverable
func (rcv *CAT) Maneuverable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Indicates if the object is maneuverable
func (rcv *CAT) MutateManeuverable(n bool) bool {
	return rcv._tab.MutateBoolSlot(40, n)
}

/// Size [meters]; blank if no data available
func (rcv *CAT) Size() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Size [meters]; blank if no data available
func (rcv *CAT) MutateSize(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Mass [kilograms]; blank if no data available
func (rcv *CAT) Mass() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Mass [kilograms]; blank if no data available
func (rcv *CAT) MutateMass(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Mass type (Dry, Wet)
func (rcv *CAT) MassType() massType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return massType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Mass type (Dry, Wet)
func (rcv *CAT) MutateMassType(n massType) bool {
	return rcv._tab.MutateInt8Slot(46, int8(n))
}

/// Vector of PAYLOADS
func (rcv *CAT) Payloads(obj *PLD.PLD, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *CAT) PayloadsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Vector of PAYLOADS
func CATStart(builder *flatbuffers.Builder) {
	builder.StartObject(23)
}
func CATAddObjectName(builder *flatbuffers.Builder, objectName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(objectName), 0)
}
func CATAddObjectId(builder *flatbuffers.Builder, objectId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(objectId), 0)
}
func CATAddNoradCatId(builder *flatbuffers.Builder, noradCatId uint32) {
	builder.PrependUint32Slot(2, noradCatId, 0)
}
func CATAddObjectType(builder *flatbuffers.Builder, objectType objectType) {
	builder.PrependInt8Slot(3, int8(objectType), 3)
}
func CATAddOpsStatusCode(builder *flatbuffers.Builder, opsStatusCode opsStatusCode) {
	builder.PrependInt8Slot(4, int8(opsStatusCode), 7)
}
func CATAddOwner(builder *flatbuffers.Builder, owner LCC.LegacyCountryCode) {
	builder.PrependInt8Slot(5, int8(owner), 0)
}
func CATAddLaunchDate(builder *flatbuffers.Builder, launchDate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(launchDate), 0)
}
func CATAddLaunchSite(builder *flatbuffers.Builder, launchSite flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(launchSite), 0)
}
func CATAddDecayDate(builder *flatbuffers.Builder, decayDate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(decayDate), 0)
}
func CATAddPeriod(builder *flatbuffers.Builder, period float64) {
	builder.PrependFloat64Slot(9, period, 0.0)
}
func CATAddInclination(builder *flatbuffers.Builder, inclination float64) {
	builder.PrependFloat64Slot(10, inclination, 0.0)
}
func CATAddApogee(builder *flatbuffers.Builder, apogee float64) {
	builder.PrependFloat64Slot(11, apogee, 0.0)
}
func CATAddPerigee(builder *flatbuffers.Builder, perigee float64) {
	builder.PrependFloat64Slot(12, perigee, 0.0)
}
func CATAddRcs(builder *flatbuffers.Builder, rcs float64) {
	builder.PrependFloat64Slot(13, rcs, 0.0)
}
func CATAddDataStatusCode(builder *flatbuffers.Builder, dataStatusCode dataStatusCode) {
	builder.PrependInt8Slot(14, int8(dataStatusCode), 0)
}
func CATAddOrbitCenter(builder *flatbuffers.Builder, orbitCenter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(orbitCenter), 0)
}
func CATAddOrbitType(builder *flatbuffers.Builder, orbitType orbitType) {
	builder.PrependInt8Slot(16, int8(orbitType), 0)
}
func CATAddDeploymentDate(builder *flatbuffers.Builder, deploymentDate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(17, flatbuffers.UOffsetT(deploymentDate), 0)
}
func CATAddManeuverable(builder *flatbuffers.Builder, maneuverable bool) {
	builder.PrependBoolSlot(18, maneuverable, false)
}
func CATAddSize(builder *flatbuffers.Builder, size float64) {
	builder.PrependFloat64Slot(19, size, 0.0)
}
func CATAddMass(builder *flatbuffers.Builder, mass float64) {
	builder.PrependFloat64Slot(20, mass, 0.0)
}
func CATAddMassType(builder *flatbuffers.Builder, massType massType) {
	builder.PrependInt8Slot(21, int8(massType), 0)
}
func CATAddPayloads(builder *flatbuffers.Builder, payloads flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(payloads), 0)
}
func CATStartPayloadsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CATEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
