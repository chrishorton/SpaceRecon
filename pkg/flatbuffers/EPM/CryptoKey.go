// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package EPM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Represents cryptographic key information
type CryptoKey struct {
	_tab flatbuffers.Table
}

func GetRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CryptoKey{}
	x.Init(buf, n+offset)
	return x
}

func FinishCryptoKeyBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsCryptoKey(buf []byte, offset flatbuffers.UOffsetT) *CryptoKey {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CryptoKey{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCryptoKeyBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *CryptoKey) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CryptoKey) Table() flatbuffers.Table {
	return rcv._tab
}

/// Public part of the cryptographic key, in hexidecimal format
func (rcv *CryptoKey) PublicKey() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Public part of the cryptographic key, in hexidecimal format
/// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
func (rcv *CryptoKey) Xpub() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
/// Private part of the cryptographic key in hexidecimal format, should be kept secret 
func (rcv *CryptoKey) PrivateKey() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Private part of the cryptographic key in hexidecimal format, should be kept secret 
/// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
func (rcv *CryptoKey) Xpriv() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
/// Address generated from the cryptographic key
func (rcv *CryptoKey) KeyAddress() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Address generated from the cryptographic key
/// Type of the address generated from the cryptographic key
func (rcv *CryptoKey) AddressType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of the address generated from the cryptographic key
/// Type of the cryptographic key (signing or encryption)
func (rcv *CryptoKey) KeyType() KeyType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return KeyType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of the cryptographic key (signing or encryption)
func (rcv *CryptoKey) MutateKeyType(n KeyType) bool {
	return rcv._tab.MutateInt8Slot(16, int8(n))
}

func CryptoKeyStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func CryptoKeyAddPublicKey(builder *flatbuffers.Builder, publicKey flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(publicKey), 0)
}
func CryptoKeyAddXpub(builder *flatbuffers.Builder, xpub flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(xpub), 0)
}
func CryptoKeyAddPrivateKey(builder *flatbuffers.Builder, privateKey flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(privateKey), 0)
}
func CryptoKeyAddXpriv(builder *flatbuffers.Builder, xpriv flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(xpriv), 0)
}
func CryptoKeyAddKeyAddress(builder *flatbuffers.Builder, keyAddress flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(keyAddress), 0)
}
func CryptoKeyAddAddressType(builder *flatbuffers.Builder, addressType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(addressType), 0)
}
func CryptoKeyAddKeyType(builder *flatbuffers.Builder, keyType KeyType) {
	builder.PrependInt8Slot(6, int8(keyType), 0)
}
func CryptoKeyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
