// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package CDM

import (
	flatbuffers "github.com/google/flatbuffers/go"

	PNM "github.com/chrishorton/spacerecon/pkg/flatbuffers/PNM"
	RFM "github.com/chrishorton/spacerecon/pkg/flatbuffers/RFM"
)

/// Conjunction Data Message
type CDM struct {
	_tab flatbuffers.Table
}

const CDMIdentifier = "$CDM"

func GetRootAsCDM(buf []byte, offset flatbuffers.UOffsetT) *CDM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CDM{}
	x.Init(buf, n+offset)
	return x
}

func FinishCDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CDMIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func CDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, CDMIdentifier)
}

func GetSizePrefixedRootAsCDM(buf []byte, offset flatbuffers.UOffsetT) *CDM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CDM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedCDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(CDMIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedCDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, CDMIdentifier)
}

func (rcv *CDM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CDM) Table() flatbuffers.Table {
	return rcv._tab
}

/// The version of the CCSDS CDM standard used
func (rcv *CDM) CcsdsCdmVers() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The version of the CCSDS CDM standard used
func (rcv *CDM) MutateCcsdsCdmVers(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// The date the CDM message was created
func (rcv *CDM) CreationDate() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The date the CDM message was created
/// The originator of the CDM message
func (rcv *CDM) Originator() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The originator of the CDM message
/// The intended recipient of the CDM message
func (rcv *CDM) MessageFor() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The intended recipient of the CDM message
/// A unique identifier for the CDM message
func (rcv *CDM) MessageId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// A unique identifier for the CDM message
/// Time of closest approach
func (rcv *CDM) Tca() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time of closest approach
/// The miss distance between the two objects
func (rcv *CDM) MissDistance() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The miss distance between the two objects
func (rcv *CDM) MutateMissDistance(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// The relative speed between the two objects
func (rcv *CDM) RelativeSpeed() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative speed between the two objects
func (rcv *CDM) MutateRelativeSpeed(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// The relative position R component
func (rcv *CDM) RelativePositionR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position R component
func (rcv *CDM) MutateRelativePositionR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// The relative position T component
func (rcv *CDM) RelativePositionT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position T component
func (rcv *CDM) MutateRelativePositionT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// The relative position N component
func (rcv *CDM) RelativePositionN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative position N component
func (rcv *CDM) MutateRelativePositionN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// The relative velocity R component
func (rcv *CDM) RelativeVelocityR() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity R component
func (rcv *CDM) MutateRelativeVelocityR(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// The relative velocity T component
func (rcv *CDM) RelativeVelocityT() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity T component
func (rcv *CDM) MutateRelativeVelocityT(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// The relative velocity N component
func (rcv *CDM) RelativeVelocityN() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The relative velocity N component
func (rcv *CDM) MutateRelativeVelocityN(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// The start time of the screening period
func (rcv *CDM) StartScreenPeriod() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The start time of the screening period
/// The end time of the screening period
func (rcv *CDM) StopScreenPeriod() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The end time of the screening period
/// The reference frame for the screening volume
func (rcv *CDM) ScreenVolumeFrame() RFM.RefFrame {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return RFM.RefFrame(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The reference frame for the screening volume
func (rcv *CDM) MutateScreenVolumeFrame(n RFM.RefFrame) bool {
	return rcv._tab.MutateInt8Slot(36, int8(n))
}

/// The shape of the screening volume
func (rcv *CDM) ScreenVolumeShape() screeningVolumeShape {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return screeningVolumeShape(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// The shape of the screening volume
func (rcv *CDM) MutateScreenVolumeShape(n screeningVolumeShape) bool {
	return rcv._tab.MutateInt8Slot(38, int8(n))
}

/// The X dimension of the screening volume
func (rcv *CDM) ScreenVolumeX() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The X dimension of the screening volume
func (rcv *CDM) MutateScreenVolumeX(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// The Y dimension of the screening volume
func (rcv *CDM) ScreenVolumeY() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The Y dimension of the screening volume
func (rcv *CDM) MutateScreenVolumeY(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// The Z dimension of the screening volume
func (rcv *CDM) ScreenVolumeZ() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The Z dimension of the screening volume
func (rcv *CDM) MutateScreenVolumeZ(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// The time the objects entered the screening volume
func (rcv *CDM) ScreenEntryTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The time the objects entered the screening volume
/// The time the objects exited the screening volume
func (rcv *CDM) ScreenExitTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The time the objects exited the screening volume
/// The probability of collision between the two objects
func (rcv *CDM) CollisionProbability() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// The probability of collision between the two objects
func (rcv *CDM) MutateCollisionProbability(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// The method used to calculate the collision probability
func (rcv *CDM) CollisionProbabilityMethod() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// The method used to calculate the collision probability
/// The first object in the CDM message
func (rcv *CDM) Object1(obj *CDMObject) *CDMObject {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CDMObject)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The first object in the CDM message
/// The second object in the CDM message
func (rcv *CDM) Object2(obj *CDMObject) *CDMObject {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CDMObject)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// The second object in the CDM message
/// Data Source for the positional information for Object 1
func (rcv *CDM) Object1Datasource(obj *PNM.PNM) *PNM.PNM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PNM.PNM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Data Source for the positional information for Object 1
/// Data Source for the positional information for Object 2
func (rcv *CDM) Object2Datasource(obj *PNM.PNM) *PNM.PNM {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(PNM.PNM)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Data Source for the positional information for Object 2
func CDMStart(builder *flatbuffers.Builder) {
	builder.StartObject(29)
}
func CDMAddCcsdsCdmVers(builder *flatbuffers.Builder, ccsdsCdmVers float64) {
	builder.PrependFloat64Slot(0, ccsdsCdmVers, 0.0)
}
func CDMAddCreationDate(builder *flatbuffers.Builder, creationDate flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(creationDate), 0)
}
func CDMAddOriginator(builder *flatbuffers.Builder, originator flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(originator), 0)
}
func CDMAddMessageFor(builder *flatbuffers.Builder, messageFor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(messageFor), 0)
}
func CDMAddMessageId(builder *flatbuffers.Builder, messageId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(messageId), 0)
}
func CDMAddTca(builder *flatbuffers.Builder, tca flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(tca), 0)
}
func CDMAddMissDistance(builder *flatbuffers.Builder, missDistance float64) {
	builder.PrependFloat64Slot(6, missDistance, 0.0)
}
func CDMAddRelativeSpeed(builder *flatbuffers.Builder, relativeSpeed float64) {
	builder.PrependFloat64Slot(7, relativeSpeed, 0.0)
}
func CDMAddRelativePositionR(builder *flatbuffers.Builder, relativePositionR float64) {
	builder.PrependFloat64Slot(8, relativePositionR, 0.0)
}
func CDMAddRelativePositionT(builder *flatbuffers.Builder, relativePositionT float64) {
	builder.PrependFloat64Slot(9, relativePositionT, 0.0)
}
func CDMAddRelativePositionN(builder *flatbuffers.Builder, relativePositionN float64) {
	builder.PrependFloat64Slot(10, relativePositionN, 0.0)
}
func CDMAddRelativeVelocityR(builder *flatbuffers.Builder, relativeVelocityR float64) {
	builder.PrependFloat64Slot(11, relativeVelocityR, 0.0)
}
func CDMAddRelativeVelocityT(builder *flatbuffers.Builder, relativeVelocityT float64) {
	builder.PrependFloat64Slot(12, relativeVelocityT, 0.0)
}
func CDMAddRelativeVelocityN(builder *flatbuffers.Builder, relativeVelocityN float64) {
	builder.PrependFloat64Slot(13, relativeVelocityN, 0.0)
}
func CDMAddStartScreenPeriod(builder *flatbuffers.Builder, startScreenPeriod flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(startScreenPeriod), 0)
}
func CDMAddStopScreenPeriod(builder *flatbuffers.Builder, stopScreenPeriod flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(stopScreenPeriod), 0)
}
func CDMAddScreenVolumeFrame(builder *flatbuffers.Builder, screenVolumeFrame RFM.RefFrame) {
	builder.PrependInt8Slot(16, int8(screenVolumeFrame), 0)
}
func CDMAddScreenVolumeShape(builder *flatbuffers.Builder, screenVolumeShape screeningVolumeShape) {
	builder.PrependInt8Slot(17, int8(screenVolumeShape), 0)
}
func CDMAddScreenVolumeX(builder *flatbuffers.Builder, screenVolumeX float64) {
	builder.PrependFloat64Slot(18, screenVolumeX, 0.0)
}
func CDMAddScreenVolumeY(builder *flatbuffers.Builder, screenVolumeY float64) {
	builder.PrependFloat64Slot(19, screenVolumeY, 0.0)
}
func CDMAddScreenVolumeZ(builder *flatbuffers.Builder, screenVolumeZ float64) {
	builder.PrependFloat64Slot(20, screenVolumeZ, 0.0)
}
func CDMAddScreenEntryTime(builder *flatbuffers.Builder, screenEntryTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(screenEntryTime), 0)
}
func CDMAddScreenExitTime(builder *flatbuffers.Builder, screenExitTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(22, flatbuffers.UOffsetT(screenExitTime), 0)
}
func CDMAddCollisionProbability(builder *flatbuffers.Builder, collisionProbability float64) {
	builder.PrependFloat64Slot(23, collisionProbability, 0.0)
}
func CDMAddCollisionProbabilityMethod(builder *flatbuffers.Builder, collisionProbabilityMethod flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(24, flatbuffers.UOffsetT(collisionProbabilityMethod), 0)
}
func CDMAddObject1(builder *flatbuffers.Builder, object1 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(25, flatbuffers.UOffsetT(object1), 0)
}
func CDMAddObject2(builder *flatbuffers.Builder, object2 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(26, flatbuffers.UOffsetT(object2), 0)
}
func CDMAddObject1Datasource(builder *flatbuffers.Builder, object1Datasource flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(27, flatbuffers.UOffsetT(object1Datasource), 0)
}
func CDMAddObject2Datasource(builder *flatbuffers.Builder, object2Datasource flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(28, flatbuffers.UOffsetT(object2Datasource), 0)
}
func CDMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
