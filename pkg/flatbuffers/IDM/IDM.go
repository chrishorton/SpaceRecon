// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package IDM

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Integrated Device Message
type IDM struct {
	_tab flatbuffers.Table
}

const IDMIdentifier = "$IDM"

func GetRootAsIDM(buf []byte, offset flatbuffers.UOffsetT) *IDM {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &IDM{}
	x.Init(buf, n+offset)
	return x
}

func FinishIDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(IDMIdentifier)
	builder.FinishWithFileIdentifier(offset, identifierBytes)
}

func IDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.BufferHasIdentifier(buf, IDMIdentifier)
}

func GetSizePrefixedRootAsIDM(buf []byte, offset flatbuffers.UOffsetT) *IDM {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &IDM{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedIDMBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	identifierBytes := []byte(IDMIdentifier)
	builder.FinishSizePrefixedWithFileIdentifier(offset, identifierBytes)
}

func SizePrefixedIDMBufferHasIdentifier(buf []byte) bool {
	return flatbuffers.SizePrefixedBufferHasIdentifier(buf, IDMIdentifier)
}

func (rcv *IDM) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *IDM) Table() flatbuffers.Table {
	return rcv._tab
}

/// Unique identifier for the EMT
func (rcv *IDM) Id() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Unique identifier for the EMT
/// Name of the EMT
func (rcv *IDM) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Name of the EMT
/// Mode of the data (real, simulated, synthetic)
func (rcv *IDM) DataMode() DataMode {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return DataMode(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Mode of the data (real, simulated, synthetic)
func (rcv *IDM) MutateDataMode(n DataMode) bool {
	return rcv._tab.MutateInt8Slot(8, int8(n))
}

/// Uplink frequency range
func (rcv *IDM) Uplink(obj *FrequencyRange) *FrequencyRange {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(FrequencyRange)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Uplink frequency range
/// Downlink frequency range
func (rcv *IDM) Downlink(obj *FrequencyRange) *FrequencyRange {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(FrequencyRange)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Downlink frequency range
/// Beacon frequency range
func (rcv *IDM) Beacon(obj *FrequencyRange) *FrequencyRange {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(FrequencyRange)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Beacon frequency range
/// Bands associated with the EMT
func (rcv *IDM) Band(obj *Band, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *IDM) BandLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Bands associated with the EMT
/// Type of polarization used
func (rcv *IDM) PolarizationType() PolarizationType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return PolarizationType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of polarization used
func (rcv *IDM) MutatePolarizationType(n PolarizationType) bool {
	return rcv._tab.MutateInt8Slot(18, int8(n))
}

/// Simple polarization configuration
func (rcv *IDM) SimplePolarization() SimplePolarization {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return SimplePolarization(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Simple polarization configuration
func (rcv *IDM) MutateSimplePolarization(n SimplePolarization) bool {
	return rcv._tab.MutateInt8Slot(20, int8(n))
}

/// Stokes parameters for polarization characterization
func (rcv *IDM) StokesParameters(obj *StokesParameters) *StokesParameters {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(StokesParameters)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// Stokes parameters for polarization characterization
/// Power required in Watts
func (rcv *IDM) PowerRequired() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Power required in Watts
func (rcv *IDM) MutatePowerRequired(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Type of power (eg. AC or DC)
func (rcv *IDM) PowerType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Type of power (eg. AC or DC)
/// Indicates if the EMT can transmit
func (rcv *IDM) Transmit() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Indicates if the EMT can transmit
func (rcv *IDM) MutateTransmit(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

/// Indicates if the EMT can receive
func (rcv *IDM) Receive() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Indicates if the EMT can receive
func (rcv *IDM) MutateReceive(n bool) bool {
	return rcv._tab.MutateBoolSlot(30, n)
}

/// Type of the sensor
func (rcv *IDM) SensorType() DeviceType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return DeviceType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of the sensor
func (rcv *IDM) MutateSensorType(n DeviceType) bool {
	return rcv._tab.MutateInt8Slot(32, int8(n))
}

/// Source of the data
func (rcv *IDM) Source() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Source of the data
/// Timestamp of the last observation
func (rcv *IDM) LastObTime() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Timestamp of the last observation
/// Lower left elevation limit
func (rcv *IDM) LowerLeftElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Lower left elevation limit
func (rcv *IDM) MutateLowerLeftElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(38, n)
}

/// Upper left azimuth limit
func (rcv *IDM) UpperLeftAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Upper left azimuth limit
func (rcv *IDM) MutateUpperLeftAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(40, n)
}

/// Lower right elevation limit
func (rcv *IDM) LowerRightElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Lower right elevation limit
func (rcv *IDM) MutateLowerRightElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(42, n)
}

/// Lower left azimuth limit
func (rcv *IDM) LowerLeftAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Lower left azimuth limit
func (rcv *IDM) MutateLowerLeftAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(44, n)
}

/// Upper right elevation limit
func (rcv *IDM) UpperRightElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Upper right elevation limit
func (rcv *IDM) MutateUpperRightElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(46, n)
}

/// Upper right azimuth limit
func (rcv *IDM) UpperRightAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Upper right azimuth limit
func (rcv *IDM) MutateUpperRightAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(48, n)
}

/// Lower right azimuth limit
func (rcv *IDM) LowerRightAzimuthLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Lower right azimuth limit
func (rcv *IDM) MutateLowerRightAzimuthLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(50, n)
}

/// Upper left elevation limit
func (rcv *IDM) UpperLeftElevationLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Upper left elevation limit
func (rcv *IDM) MutateUpperLeftElevationLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(52, n)
}

/// Right geostationary belt limit
func (rcv *IDM) RightGeoBeltLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Right geostationary belt limit
func (rcv *IDM) MutateRightGeoBeltLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(54, n)
}

/// Left geostationary belt limit
func (rcv *IDM) LeftGeoBeltLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Left geostationary belt limit
func (rcv *IDM) MutateLeftGeoBeltLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(56, n)
}

/// Magnitude limit of the sensor
func (rcv *IDM) MagnitudeLimit() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Magnitude limit of the sensor
func (rcv *IDM) MutateMagnitudeLimit(n float64) bool {
	return rcv._tab.MutateFloat64Slot(58, n)
}

/// Indicates if the site is taskable
func (rcv *IDM) Taskable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Indicates if the site is taskable
func (rcv *IDM) MutateTaskable(n bool) bool {
	return rcv._tab.MutateBoolSlot(60, n)
}

func IDMStart(builder *flatbuffers.Builder) {
	builder.StartObject(29)
}
func IDMAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func IDMAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func IDMAddDataMode(builder *flatbuffers.Builder, dataMode DataMode) {
	builder.PrependInt8Slot(2, int8(dataMode), 0)
}
func IDMAddUplink(builder *flatbuffers.Builder, uplink flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(uplink), 0)
}
func IDMAddDownlink(builder *flatbuffers.Builder, downlink flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(downlink), 0)
}
func IDMAddBeacon(builder *flatbuffers.Builder, beacon flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(beacon), 0)
}
func IDMAddBand(builder *flatbuffers.Builder, band flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(band), 0)
}
func IDMStartBandVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func IDMAddPolarizationType(builder *flatbuffers.Builder, polarizationType PolarizationType) {
	builder.PrependInt8Slot(7, int8(polarizationType), 0)
}
func IDMAddSimplePolarization(builder *flatbuffers.Builder, simplePolarization SimplePolarization) {
	builder.PrependInt8Slot(8, int8(simplePolarization), 0)
}
func IDMAddStokesParameters(builder *flatbuffers.Builder, stokesParameters flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(stokesParameters), 0)
}
func IDMAddPowerRequired(builder *flatbuffers.Builder, powerRequired float64) {
	builder.PrependFloat64Slot(10, powerRequired, 0.0)
}
func IDMAddPowerType(builder *flatbuffers.Builder, powerType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(powerType), 0)
}
func IDMAddTransmit(builder *flatbuffers.Builder, transmit bool) {
	builder.PrependBoolSlot(12, transmit, false)
}
func IDMAddReceive(builder *flatbuffers.Builder, receive bool) {
	builder.PrependBoolSlot(13, receive, false)
}
func IDMAddSensorType(builder *flatbuffers.Builder, sensorType DeviceType) {
	builder.PrependInt8Slot(14, int8(sensorType), 0)
}
func IDMAddSource(builder *flatbuffers.Builder, source flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(15, flatbuffers.UOffsetT(source), 0)
}
func IDMAddLastObTime(builder *flatbuffers.Builder, lastObTime flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(lastObTime), 0)
}
func IDMAddLowerLeftElevationLimit(builder *flatbuffers.Builder, lowerLeftElevationLimit float64) {
	builder.PrependFloat64Slot(17, lowerLeftElevationLimit, 0.0)
}
func IDMAddUpperLeftAzimuthLimit(builder *flatbuffers.Builder, upperLeftAzimuthLimit float64) {
	builder.PrependFloat64Slot(18, upperLeftAzimuthLimit, 0.0)
}
func IDMAddLowerRightElevationLimit(builder *flatbuffers.Builder, lowerRightElevationLimit float64) {
	builder.PrependFloat64Slot(19, lowerRightElevationLimit, 0.0)
}
func IDMAddLowerLeftAzimuthLimit(builder *flatbuffers.Builder, lowerLeftAzimuthLimit float64) {
	builder.PrependFloat64Slot(20, lowerLeftAzimuthLimit, 0.0)
}
func IDMAddUpperRightElevationLimit(builder *flatbuffers.Builder, upperRightElevationLimit float64) {
	builder.PrependFloat64Slot(21, upperRightElevationLimit, 0.0)
}
func IDMAddUpperRightAzimuthLimit(builder *flatbuffers.Builder, upperRightAzimuthLimit float64) {
	builder.PrependFloat64Slot(22, upperRightAzimuthLimit, 0.0)
}
func IDMAddLowerRightAzimuthLimit(builder *flatbuffers.Builder, lowerRightAzimuthLimit float64) {
	builder.PrependFloat64Slot(23, lowerRightAzimuthLimit, 0.0)
}
func IDMAddUpperLeftElevationLimit(builder *flatbuffers.Builder, upperLeftElevationLimit float64) {
	builder.PrependFloat64Slot(24, upperLeftElevationLimit, 0.0)
}
func IDMAddRightGeoBeltLimit(builder *flatbuffers.Builder, rightGeoBeltLimit float64) {
	builder.PrependFloat64Slot(25, rightGeoBeltLimit, 0.0)
}
func IDMAddLeftGeoBeltLimit(builder *flatbuffers.Builder, leftGeoBeltLimit float64) {
	builder.PrependFloat64Slot(26, leftGeoBeltLimit, 0.0)
}
func IDMAddMagnitudeLimit(builder *flatbuffers.Builder, magnitudeLimit float64) {
	builder.PrependFloat64Slot(27, magnitudeLimit, 0.0)
}
func IDMAddTaskable(builder *flatbuffers.Builder, taskable bool) {
	builder.PrependBoolSlot(28, taskable, false)
}
func IDMEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
